# heroes-strategy
Итоговый проект «Разработка стратегии в стиле боя в игре "Герои Меча и Магии 3" против искусственного интеллекта» по дисциплине "Алгоритмы и структуры данных". 1-й семестр 1-го курса МИФИ ИИКС РПО (2024-2025 уч. г).

## Введение

В данном проекте необходимо имплементировать 4 алгоритма (метода), которые определяют ключевую игровую механику: генерацию армии, симуляцию боя, выбор подходящих для атаки юнитов и нахождение кратчайшего пути между атакующим и целью.

Игровой проект состоит из трех внутренних проектов:

- [heroes](./initial-files/heroes.zip) - основной проект игры.
  - В нем происходит рендеринг, отрисовка интерфейса и применение реализованных алгоритмов.
  - Использует как библиотеку проект `heroes_task` (изначально вместо реализованного в задании кода содержит обфусцированный `.jar` файл с вариантом реализации, предполагается, что этот файл заменится `.jar` файлом с собственной реализацией).
- [heroes_task](./initial-files/heroes_task.zip) - проект алгоритмов игры, которые необходимо реализовать.
  - Содержит заготовку имплементации четырех алгоритмов.
  - Использует как зависимость проект `heroes_task_lib`.
- [heroes_task_lib](./initial-files/history_task_lib.jar) - проект библиотеки игры.
  - Содержит основные классы и интерфейсы, необходимые как проекту игры, так и проекту задания.

## Подготовка к проекту

### Как запустить игру

Для начала необходимо распаковать архив `heroes.zip` в любое удобное место. При этом на пути архива с распакованной игрой не должно быть кириллицы.

Существует два способа запуска игры:

1. При установленной `Java` дважды щелкнуть левой кнопкой мыши файл `Heroes Battle-1.0.0.jar`.
2. Открыть терминал в папке с распакованной игрой и выполнить команду `java -jar "Heroes Battle-1.0.0.jar"`. Этот вариант предпочтительнее, так как с ним возможно будет видеть лог работы игры в терминале.

### Дано

В проекте библиотеки игры `heroes_task_lib` определено четыре интерфейса, методы которых необходимо имплементировать в проекте `heroes_task` согласно документации. Это интерфейсы:

- `GeneratePreset`.
- `SimulateBattle`.
- `SuitableForAttackUnitsFinder`.
- `UnitTargetPathFinder`.

Интерфейсы отвечают за реализацию следующего логического функционала внутри основного проекта игры:

- `GeneratePreset` содержит метод `Army generate(List<Unit> unitList, int maxPoints)`, который отвечает за генерацию пресета армии противника.
- `SimulateBattle` содержит метод `void simulate(Army playerArmy, Army computerArmy) throws InterruptedException` и отвечает за осуществление симуляции боя.
- `SuitableForAttackUnitsFinder` содержит метод `List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)` и отвечает за создание перечня подходящий для атаки юнитов.
- `UnitTargetPathFinder` содержит метод `List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)` и отвечает за поиск кратчайшего пути между атакующим и атакуемым юнитом.

Для выполнения задания дан проект `heroes_task` с уже подключенной библиотекой `heroes_task_lib` и созданными заготовками имплементации для каждого интерфейса.

### Метод generate интерфейса GeneratePreset

Метод формирует пресет армии компьютера, т.е. такой набор юнитов разного типа, который был бы максимально эффективен в первую очередь по соотношению атаки к стоимости соотношению здоровья к стоимости. При этом соблюдается ограничение в 11 юнитов каждого типа. Цель метода - создать армию компьютера.

Метод имеет следующую сигнатуру: `Army generate(List<Unit> unitList, int maxPoints)`, где:

- Параметр `unitList` - список юнитов. Содержит объект юнита каждого типа. На его основе происходит заполнение армии компьютера. Сейчас существует 4 типа юнитов: лучник, всадник, мечник и копейщик.
- Параметр `maxPoints` - максимальное число очков в сумме для всех юнитов. В этом случае - 1500.

Возвращаемое значение - возвращает объект армии компьютера со списком юнитов внутри нее.

Алгоритмическая сложность должна быть `O(n*m)` или лучше, где:

- `n` - общее число типов юнитов.
- `m` - максимальное число юнитов в армии.

### Метод simulate интерфейса SimulateBattle

Метод осуществляет симуляцию боя между армией игрока и армией компьютера. Цель метода - провести бой, следуя установленным правилам.

Симуляция происходит так:

1. На каждой раунде юниты сортируются по убыванию значения атаки, чтобы первыми ходили самые сильные.
2. Пока в обеих армиях есть живые юниты, они атакуют друг друга по очереди.
3. Если у одной из армий заканчиваются юниты, она ожидает завершения ходов оставшихся юнитов противника.
4. Когда все юниты походили, раунд завершается, и начинается следующий.

Юниты, которые погибли (значение поля `isAlive` - `false`) и еще не походили, исключаются из очередей в момент их смерти, и очереди хода пересчитываются.

Если количество юнитов в армиях становится разным из-за потерь, очередность ходов может измениться.

Юниты атакуют друг друга с помощью метода `unit.getProgram().attack()`, который возвращает цель атаки (юнит противника) или `null`, если цель не найдена.

После каждой атаки необходимо вывести лог с помощью метода `printBattleLog.printBattleLog(unit, target)`, где `unit` - атакующий юнит, а `target` - цель атаки.

Симуляция завершается, когда у одной из армий не остается живых юнитов, способных сделать ход.

Метод имеет следующую сигнатуру: `simulate(Army playerArmy, Army computerArmy)`, где:

- Параметр `playerArmy` - объект армии игрока, содержащий список ее юнитов.
- Параметр `computerArmy` - объект армии компьютера, содержащий список ее юнитов.

Алгоритмическая сложность данного алгоритма должна быть `O(n^2*log(n))` или лучше, если принять, что метод атаки юнита работает за `O(1)`, где `n` - общее количество юнитов в армии.

### Метод getSuitableUnits интерфейса SuitableForAttackUnitsFinder

Метод определяет список юнитов, подходящих для атаки для атакующего юнита одной из армий. Цель метода - исключить ненужные попытки найти кратчайший путь между юнитами, которые не могут атаковать друг друга.

Подходящий юнит для атаки для атакующей армии компьютера - это юнит армии игрока, который не закрыт справа (по координате `Y`) другим юнитом армии игрока.

Подходящий юнит для атаки для атакующей армии игрока - это юнит армии компьютера, который не закрыт слева (по координате `Y`) другим юнитом армии компьютера.

Метод имеет следующую сигнатуру: `List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)`, где:

- Параметр `unitsByRow` - трехслойный массив юнитов противника. Для юнита из атакующей армии компьютера эти юниты находятся на координатах `24..26` по оси `X`. Для армии игрока они располагаются на координатах `0..2` по оси `X` (фактически, это юниты армии компьютера).
- Параметр `isLeftArmyTarget` - параметр, указывающий, юниты какой армии подвергаются атаке. Если значение `true`, то атаке подвергаются юниты армии компьютера (левая армия), если `false` - юниты армии игрока (правая армия).

Возвращаемое значение - метод возвращает список юнитов, подходящих для атаки, для юнита атакующей армии.

Алгоритмическая сложность метода должна быть `O(n*m)` или лучше, что означает линейную сложность на двумерной плоскости, где `n` - количество юнитов в ряду, а `m` - количество рядов. Т.к. количество рядов фиксировано и равно 3м, алгоритм фактически должен иметь линейную сложность `O(n)` или лучше.

### Метод getTargetPath интерфейса UnitTargetPathFinder

Метод определяет кратчайший маршрут между атакующим и атакуемым юнитом и возвращает его в виде списка объектов, содержащих координаты каждой точки данного кратчайшего пути.

Цель метода - найти кратчайший путь между атакующим и атакуемым юнитом. Т.е. для атакующего юнита с координатами `x = 1` и `y = 2` и атакуемого юнита `x = 0` и `y = 0` результатом станет список `[Edge(1, 2), Edge(1, 1), Edge(1, 0)]`.

Для определения кратчайшего пути должен быть использован один из алгоритмов теории графов.

Метод имеет следующую сигнатуру: `List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)`, где:

- Параметр `attackUnit` - юнит, который атакует.
- Параметр `targetUnit` - юнит, который подвергается атаке.
- Параметр `existingUnitList` - список всех существующих юнитов.

Возвращаемое значение - список объектов `Edge`, т.е. координат клеток пути от атакующего юнита до атакуемого юнита включительно. Если маршрут не найден - возвращается пустой список.

Алгоритмическая сложность данного метода составляет `O((WIDTH*HEIGHT)*log(WIDTH*HEIGHT))`, где:

- `WIDTH` - ширина игрового поля (27).
- `HEIGHT` - высота игрового поля (21).

Алгоритм, представленный в коде использует один из алгоритмов теории графов для нахождения кратчайшего пути на поле с препятствиями, где некоторые клетки заняты юнитами. Основные шаги включают инициализацию структуры данных для хранения расстояний, обработку соседних клеток и определение пути.

### Описание библиотеки heroes_task_lib

Библиотека содержит в себе основные классы и интерфейсы, необходимые как проекту игры, так и проекту задания.

В проекте библиотеки игры `heroes_task_lib` определено 4 интерфейса, методы которых необходимо имплементировать в проекте `heroes_task`, согласно документации. Это интерфейсы:

- `GeneratePreset`.
- `SimulateBattle`.
- `SuitableForAttackUnitsFinder`.
- `UnitTargetPathFinder`.

Интерфейсы отвечают за реализацию следующего логического функционала внутри основного проекта игры:

1. `GeneratePreset` содержит метод `Army generate(List<Unit> unitList, int maxPoints)`, который отвечает за генерацию пресета армии противника.
2. `SimulateBattle` содержит метод `void simulate(Army playerArmy, Army computerArmy) throws InterruptedException` и отвечает за осуществление симуляции боя.
3. `SuitableForAttackUnitsFinder` содержит метод `List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)` и отвечает за создание перечня подходящих для атаки юнитов.
4. `UnitTargetPathFinder` содержит метод `List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)` и отвечает за поиск кратчайшего пути между атакующим и атакуемым юнитом.
5. Интерфейс `PrintBattleLog` содержит метод `void printBattleLog(Unit attackingUnit, Unit target)` и отвечает за печать лога после каждого хода юнита. Его не нужно реализовывать - только использовать.

Также библиотека содержит следующие классы, необходимые как для работы основной игры, так и для реализации имплементации интерфейсов, описанных в проекте `heroes_task`:

#### Unit

Класс `Unit` содержит основные характеристики юнита, такие как уникальное имя, тип, тип атаки, здоровье, базовую атаку и стоимость:

| Название поля | Тип поля | Описание поля                                  |
|---------------|----------|------------------------------------------------|
| name          | String   | Уникальное имя юнита в рамках армии            |
| unitType      | String   | Тип юнита: лучник, копейщик мечник или всадник |
| health        | int      | Количество здоровья юнита                      |
| baseAttack    | int      | Количество урона, наносимое юнитом при атаке   |
| cost          | int      | Стоимость юнита в очках                        |
| attackType    | String   | Тип атаки юнита, дистанционная или ближняя     |
| program       | Program  | Программа поведения юнита при атаке            |
| isAlive       | boolean  | Статус юнита: живой или мертвый                |

#### Army

Класс `Army` содержит список юнитов армии, а также суммарное количество очков юнитов данной армии.

| Название поля | Тип поля | Описание поля                             |
|---------------|----------|-------------------------------------------|
| units         | List     | Список юнитов в армии                     |
| points        | int      | Суммарное количество очков юнитов в армии |

#### Program

Класс `Program` содержит общую часть логики программы поведения каждого юнита при атаке.

| Название поля | Тип поля | Описание поля                               |
|---------------|----------|---------------------------------------------|
| unit          | Unit     | Ссылка на юнит которому назначена программа |
| allyArmy      | Army     | Ссылка на армию союзников                   |
| enemyArmy     | int      | Ссылка на армию противника                  |
| simSpeed      | int      | Скорость симуляции боя                      |

#### Edge

Класс `Edge` - фактически класс объекта пути, содержит в себе координаты `x` и `y`.

| Название поля | Тип поля | Описание поля                    |
|---------------|----------|----------------------------------|
| x             | int      | Координата икс на игровом поле   |
| y             | int      | Координата игрек на игровом поле |

#### EdgeDistance

Класс `EdgeDistance` - класс объекта пути, который хранит в себе расстояние до стартовой точки.

| Название поля | Тип поля | Описание поля                                                      |
|---------------|----------|--------------------------------------------------------------------|
| x             | int      | Координата икс на игровом поле                                     |
| y             | int      | Координата игрек на игровом поле                                   |
| distance      | int      | Расстояние в клетках от начальной точки до текущей точки координат |

### Описание классов программы действия юнитов

Необходимо использовать метод `unit.getProgram().attack()` после каждого юнита для атаки юнитом армии компьютера или игрока. Все эти методы уже реализованы, каждому типу юнитом, с которым будет вестись работы, уже назначена соответствующая программа.

- Класс `ComputerArcherProgram` - класс с реализацией метода `attack()` лучника армии компьютера.
- Класс `ComputerKnightProgram` - класс с реализацией метода `attack()` всадника армии компьютера.
- Класс `ComputerPikemanProgram` - класс с реализацией метода `attack()` копейщика армии компьютера.
- Класс `ComputerSwordsmanProgram` - класс с реализацией метода `attack()` мечника армии компьютера.
- Класс `UserArcherProgram` - класс с реализацией метода `attack()` лучника армии игрока.
- Класс `UserKnightProgram` - класс с реализацией метода `attack()` всадника армии игрока.
- Класс `UserPikemanProgram` - класс с реализацией метода `attack()` копейщика армии игрока.
- Класс `UserSwordsmanProgram` - класс с реализацией метода `attack()` мечника армии игрока.

## Критерии оценки

В сумме за реализацию и сборку проекта можно получить до 31 балла.

Реализация методов рамках задания оценивается по-разному.

### 5 баллов

По 5 баллов максимум можно получить за:

- Метод `getSuitableUnits()` интерфейса `SuitableForAttackUnitsFinder`.
- Метод `simulate()` интерфейса `SimulateBattle`.

Баллы при этом начисляются следующим образом:

- Метод работает корректно - 2 балла.
- Приведено доказательство алгоритмической сложности алгоритма - 1 балл.
- Алгоритмическая сложность такая же, как в примере - 1 балл.
- Алгоритмическая сложность лучше, чем в примере - 1 балл. Соответственно, если сложность написанного алгоритма лучше, чем в примере, присуждается 2 балла: 1 балл за достижение сложности из примера и еще 1 балл за ее превосхождение.

### 10 баллов

По 10 баллов максимум можно получить за:

- Метод `generate()` интерфейса `GeneratePreset`.
- Метод `getTargetPath()` интерфейса `UnitTargetPathFinder`.

Баллы при этом начисляются следующим образом:

- Метод работает корректно - 4 балла.
- Выбран корректный алгоритм - 1 балл.
- Приведено доказательство алгоритмической сложности алгоритма - 2 балла.
- Алгоритмическая сложность такая же, как в примере - 1 балл.
- Алгоритмическая сложность лучше, чем в примере - 2 балла. Соответственно, если сложность написанного алгоритма лучше, чем в примере, присуждается 3 балла: 1 балл за достижение сложности из примера и еще 2 балла за ее превосхождение.

### Задача

Необходимо реализовать все четыре метода в проекте `heroes_task`, а затем собрать проект и поместить полученный `.jar` файл в папку `jars` игры, которая была распакована из архива `heroes.zip`.

### Этапы выполнения задания

#### 1. Подготовка

1. Изучить постановку задачи и описание алгоритмов, которые необходимо реализовать.
2. Распаковать необходимые архивы (`heroes.zip` и `heroes_task.zip`).
3. Открыть проект `heroes_task.zip` в IDE, затем найти в директории `src/programs` четыре заготовки для имплементации интерфейсов библиотеки `heroes_task_lib`, открыть их.

За данный этап не начисляются баллы.

#### 2. Реализация метода getSuitableUnits() интерфейса SuitableForAttackUnitsFinder

1. Открыть класс `SuitableForAttackUnitsFinderImpl` и найти там переопределенный метод `getSuitableUnits()`.
2. Написать его реализацию.
3. Проверить, что метод работает корректно.
4. Рассчитать алгоритмическую сложность написанной реализации алгоритма и составить ее доказательство. Для этого сначала рассчитать сложность для каждого этапа алгоритма, а затем - итоговую сложность. Убедиться, что сложность написанного алгоритма такая же или лучше, чем в документации.

За данный этап можно получить максимум 5 баллов.

#### 3. Реализация метода generate() интерфейса GeneratePreset

1. Открыть класс `GeneratePresetImpl` и найти там переопределенный метод `generate()`.
2. Написать его реализацию.
3. Проверить, что метод работает корректно.
4. Рассчитать алгоритмическую сложность написанной реализации алгоритма и составить ее доказательство. Для этого сначала рассчитать сложность для каждого этапа алгоритма, а затем - итоговую сложность. Убедиться, что сложность написанного алгоритма такая же или лучше, чем в документации.

За данный этап можно получить максимум 10 баллов.

#### 4. Реализация метода getTargetPath() интерфейса UnitTargetPathFinder

1. Открыть класс `UnitTargetPathFinderImpl` и найти там переопределенный метод `getTargetPath`.
2. Написать его реализацию.
3. Проверить, что метод работает корректно.
4. Рассчитать алгоритмическую сложность написанной реализации алгоритма и составить ее доказательство. Для этого сначала рассчитать сложность для каждого этапа алгоритма, а затем - итоговую сложность. Убедиться, что сложность написанного алгоритма такая же или лучше, чем в документации.

За данный этап можно получить максимум 10 баллов.

#### 5. Реализация метода simulate() интерфейса SimulateBattle

1. Открыть класс `SimulateBattleImpl` и найти там переопределенный метод `simulate()`.
2. Написать его реализацию.
3. Проверить, что метод работает корректно.
4. Рассчитать алгоритмическую сложность написанной реализации алгоритма и составить ее доказательство. Для этого сначала рассчитать сложность для каждого этапа алгоритма, а затем - итоговую сложность. Убедиться, что сложность написанного алгоритма такая же или лучше, чем в документации.

За данный этап можно получить максимум 5 баллов.

#### 6. Сборка проекта

1. Убедиться, что реализованы все 4 метода.
2. Настроить артефакт в IntelliJ IDEA. Это можно сделать, открыв меню `File` > `Project Structure` > `Artifacts`. Затем нажать на кнопку "плюс" и выбрать "JAR" из выпадающего списка. После этого выбрать опцию "From modules with dependencies".
3. После завершения всех настроек - собрать артефакт, выбрав `Build` > `Build Artifacts` и артефакт для сборки.
4. После выполнения этих шагов в указанном каталоге должен появиться `.jar` файл, содержащий все необходимые файлы для работы приложения. Если при запуска полученного `.jar` файла возникают проблемы, возможно, стоит проверить пути к библиотекам и классам в настройках артефакта.
5. Переместить полученный `.jar` файл из директории `out/artifacts/heroes_student_task_jar` в директорию `jars` распакованной игры, удалив из нее предыдущий `.jar` файл.

За данный этап можно получить максимум 1 балл.

#### 7. Запуск игры

1. Запустить игру одним из двух способов, описанных выше.
2. Нажать "начать новую игру", далее нажать "создать армию".
3. Нажать кнопку "сгенерировать пресет", чтобы проверить, как работает реализованный метод `generate()`.
4. Далее руками расставить юниты армии игрока, выбрав текущий юнит нажатием соответствующей кнопки. Разместить его, нажав на обведенную красной линией часть игрового поля.
5. После того, как создали армию игрока и компьютера, нажать кнопку "создать армию" и вернуться в меню запуска боя.
6. Нажать кнопку "начать бой". Запуск боя запустит написанный метод `simulate()`, что даст возможность проверить его работу. Каждый ход юнита также позволит проверить работу методов `getSuitableUnits()`, если юнит смог найти цель для атаки и `getTargetPath()`, если юнит смог корректно дойти до цели атаки и атаковать ее или пропустил ход.
